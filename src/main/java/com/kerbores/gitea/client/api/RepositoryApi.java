/*
 * Gitea API. This documentation describes the Gitea API.
 *
 * OpenAPI spec version: 1.1.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git Do not edit the class
 * manually.
 */

package com.kerbores.gitea.client.api;

import java.io.File;
import java.util.List;

import com.kerbores.gitea.client.Maps;
import com.kerbores.gitea.client.model.AddCollaboratorOption;
import com.kerbores.gitea.client.model.AnnotatedTag;
import com.kerbores.gitea.client.model.Attachment;
import com.kerbores.gitea.client.model.Branch;
import com.kerbores.gitea.client.model.Commit;
import com.kerbores.gitea.client.model.ContentsResponse;
import com.kerbores.gitea.client.model.CreateFileOptions;
import com.kerbores.gitea.client.model.CreateForkOption;
import com.kerbores.gitea.client.model.CreateHookOption;
import com.kerbores.gitea.client.model.CreateKeyOption;
import com.kerbores.gitea.client.model.CreatePullRequestOption;
import com.kerbores.gitea.client.model.CreateReleaseOption;
import com.kerbores.gitea.client.model.CreateRepoOption;
import com.kerbores.gitea.client.model.CreateStatusOption;
import com.kerbores.gitea.client.model.DeleteFileOptions;
import com.kerbores.gitea.client.model.DeployKey;
import com.kerbores.gitea.client.model.EditAttachmentOptions;
import com.kerbores.gitea.client.model.EditGitHookOption;
import com.kerbores.gitea.client.model.EditHookOption;
import com.kerbores.gitea.client.model.EditPullRequestOption;
import com.kerbores.gitea.client.model.EditReleaseOption;
import com.kerbores.gitea.client.model.EditRepoOption;
import com.kerbores.gitea.client.model.FileDeleteResponse;
import com.kerbores.gitea.client.model.FileResponse;
import com.kerbores.gitea.client.model.GitBlobResponse;
import com.kerbores.gitea.client.model.GitHook;
import com.kerbores.gitea.client.model.GitTreeResponse;
import com.kerbores.gitea.client.model.Hook;
import com.kerbores.gitea.client.model.MergePullRequestOption;
import com.kerbores.gitea.client.model.MigrateRepoForm;
import com.kerbores.gitea.client.model.PullRequest;
import com.kerbores.gitea.client.model.Reference;
import com.kerbores.gitea.client.model.Release;
import com.kerbores.gitea.client.model.RepoTopicOptions;
import com.kerbores.gitea.client.model.Repository;
import com.kerbores.gitea.client.model.SearchResults;
import com.kerbores.gitea.client.model.Status;
import com.kerbores.gitea.client.model.Tag;
import com.kerbores.gitea.client.model.TopicName;
import com.kerbores.gitea.client.model.TopicResponse;
import com.kerbores.gitea.client.model.TrackedTime;
import com.kerbores.gitea.client.model.UpdateFileOptions;
import com.kerbores.gitea.client.model.User;
import com.kerbores.gitea.client.model.WatchInfo;
import com.kerbores.gitea.client.request.ApiClient;

public class RepositoryApi {
    ApiClient apiClient;

    public RepositoryApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Migrate a remote git repository
     * 
     * @param repository
     *            MigrateRepoForm
     * @return Repository
     */
    public Repository migrate(MigrateRepoForm repository) {
        return apiClient.deserialize(apiClient.postBody("/repos/migrate", repository), Repository.class);
    }

    /**
     * Search for repositories
     * 
     * @param key
     *            keyword
     * @param topic
     *            Limit search to repositories with keyword as topic
     * @param includeDesc
     *            include search of keyword within repository description
     * @param uid
     *            search only for repos that the user with the given id owns or
     *            contributes to
     * @param priorityOwnerId
     *            repo owner to prioritize in the results
     * @param starredBy
     *            search only for repos that the user with the given id has
     *            starred
     * @param _private
     *            include private repositories this user has access to (defaults
     *            to true)
     * @param template
     *            include template repositories this user has access to
     *            (defaults to true)
     * @param page
     *            page number of results to return (1-based)
     * @param limit
     *            page size of results, maximum page size is 50
     * @param mode
     *            type of repository to search for. Supported values are "fork",
     *            "source", "mirror" and "collaborative"
     * @param exclusive
     *            if uid is given, search only for repos that the user owns
     * @param sort
     *            sort repos by attribute. Supported values are "alpha",
     *            "created", "updated", "size", and "id". Default is "alpha"
     * @param order
     *            sort order, either "asc" (ascending) or "desc" (descending).
     *            Default is "asc", ignored if "sort" is not specified.
     * @return SearchResults
     */
    public SearchResults search(String key,
                                boolean topic,
                                boolean includeDesc,
                                long uid,
                                long priorityOwnerId,
                                long starredBy,
                                boolean _private,
                                boolean template,
                                long page,
                                long limit,
                                String mode,
                                boolean exclusive,
                                String sort,
                                String order) {
        return apiClient.deserialize(apiClient.get("/repos/search",
                                                   Maps.NEW("q", key)
                                                       .add("topic", topic)
                                                       .add("includeDesc", includeDesc)
                                                       .add("uid", uid)
                                                       .add("priority_owner_id", priorityOwnerId)
                                                       .add("starredBy", starredBy)
                                                       .add("private", _private)
                                                       .add("template", template)
                                                       .add("page", page)
                                                       .add("limit", limit)
                                                       .add("mode", mode)
                                                       .add("exclusive", exclusive)
                                                       .add("sort", sort)
                                                       .add("order", order),
                                                   null),
                                     SearchResults.class);
    }

    /**
     * Get a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return Repository
     */
    public Repository repository(String owner, String repo) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s", owner, repo)), Repository.class);
    }

    /**
     * Edit a repository's properties. Only fields that are set will be changed.
     * 
     * @param owner
     *            owner of the repo to edit
     * @param repo
     *            name of the repo to edit
     * @param repository
     *            EditRepoOption
     * @return Repository
     */
    public Repository repository(String owner, String repo, EditRepoOption repository) {
        return apiClient.deserialize(apiClient.patch(String.format("/repos/%s/%s", owner, repo), repository), Repository.class);
    }

    /**
     * Delete a repository
     * 
     * @param owner
     *            owner of the repo to delete
     * @param repo
     *            name of the repo to delete
     * @return success true else false
     */
    public boolean deleteRepository(String owner, String repo) {
        return apiClient.delete(String.format("/repos/%s/%s", owner, repo)).isOk();
    }

    /**
     * Get an archive of a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param archive
     *            archive to download, consisting of a git reference and archive
     * @return success?
     */
    public boolean archive(String owner, String repo, String archive) {
        return apiClient.get(String.format("/repos/%s/%s/archive/%s", owner, repo, archive)).isOk();
    }

    /**
     * List a repository's branches
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return BranchList
     */
    public List<Branch> branchs(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/branchs", owner, repo)), Branch.class);
    }

    /**
     * Retrieve a specific branch from a repository, including its effective
     * branch protection
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param branch
     *            branch to get
     * @return Branch
     */
    public Branch branch(String owner, String repo, String branch) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/branchs/%s", owner, repo, branch)), Branch.class);
    }

    /**
     * List a repository's collaborators
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return UserList
     */
    public List<User> collaborators(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/collaborators", owner, repo)), User.class);
    }

    /**
     * Check if a user is a collaborator of a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param collaborator
     *            username of the collaborator
     * @return true if a user is a collaborator of a repository
     */
    public boolean isCollaborator(String owner, String repo, String collaborator) {
        return apiClient.get(String.format("/repos/%s/%s/collaborators/%s", owner, repo, collaborator)).isOk();
    }

    /**
     * Add a collaborator to a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param collaborator
     *            username of the collaborator to add
     * @param option
     *            AddCollaboratorOption
     * @return success true else false
     */
    public boolean collaborator(String owner, String repo, String collaborator, AddCollaboratorOption option) {
        return apiClient.put(String.format("/repos/%s/%s/collaborators/%s", owner, repo, collaborator), option).isOk();
    }

    /**
     * Delete a collaborator from a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param collaborator
     *            username of the collaborator to delete
     * @return success true else false
     */
    public boolean deleteCollaborator(String owner, String repo, String collaborator) {
        return apiClient.delete(String.format("/repos/%s/%s/collaborators/%s", owner, repo, collaborator)).isOk();
    }

    /**
     * Get a list of all commits from a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            SHA or branch to start listing commits from (usually 'master')
     * @param page
     *            page number of requested commits
     * @return CommitList
     */
    public List<Commit> commits(String owner, String repo, String sha, long page) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/commits", owner, repo),
                                                         Maps.NEW("sha", sha)
                                                             .add("page", page),
                                                         null),
                                           Commit.class);
    }

    /**
     * Get a commit's combined status, by branch/tag/commit reference
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param ref
     *            name of branch/tag/commit
     * @param page
     *            page number of results
     * @return Status
     */
    public Status status(String owner, String repo, String ref, long page) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/commits/%s/statuses", owner, repo, ref),
                                                   Maps.NEW("page", page),
                                                   null),
                                     Status.class);
    }

    /**
     * Gets the metadata of all the entries of the root dir
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param ref
     *            The name of the commit/branch/tag. Default the repository’s
     *            default branch (usually master)
     * @return ContentsListResponse
     */
    public List<ContentsResponse> contents(String owner, String repo, String ref) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/contents", owner, repo),
                                                         Maps.NEW("ref", ref),
                                                         null),
                                           ContentsResponse.class);
    }

    /**
     * Gets the metadata and contents (if a file) of an entry in a repository,
     * or a list of entries if a dir
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param filepath
     *            path of the dir, file, symlink or submodule in the repo
     * @param ref
     *            The name of the commit/branch/tag. Default the repository’s
     *            default branch (usually master)
     * @return ContentsListResponse
     */
    public List<ContentsResponse> contents(String owner, String repo, String filepath, String ref) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/contents/%s", owner, repo, filepath),
                                                         Maps.NEW("ref", ref),
                                                         null),
                                           ContentsResponse.class);
    }

    /**
     * Update a file in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param filepath
     *            path of the file to update
     * @param options
     *            UpdateFileOptions
     * @return FileResponse
     */
    public FileResponse contents(String owner, String repo, String filepath, UpdateFileOptions options) {
        return apiClient.deserialize(apiClient.put(String.format("/repos/%s/%s/contents/%s", owner, repo, filepath), options),
                                     FileResponse.class);
    }

    /**
     * Create a file in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param filepath
     *            path of the file to create
     * @param options
     *            CreateFileOptions
     * @return FileResponse
     */
    public FileResponse contents(String owner, String repo, String filepath, CreateFileOptions options) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/contents/%s", owner, repo, filepath), options),
                                     FileResponse.class);
    }

    /**
     * Delete a file in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param filepath
     *            path of the file to delete
     * @param options
     *            DeleteFileOptions
     * @return FileDeleteResponse
     */
    public FileDeleteResponse contents(String owner, String repo, String filepath, DeleteFileOptions options) {
        return apiClient.deserialize(apiClient.delete(String.format("/repos/%s/%s/contents/%s", owner, repo, filepath), options),
                                     FileDeleteResponse.class);
    }

    /**
     * Get the EditorConfig definitions of a file in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param filepath
     *            filepath of file to get
     * @return success
     */
    public boolean editorconfig(String owner, String repo, String filepath) {
        return apiClient.get(String.format("/repos​/%s/%s/editorconfig​/%s", owner, repo, filepath)).isOk();
    }

    /**
     * List a repository's forks
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return RepositoryList
     */
    public List<Repository> forks(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/forks", owner, repo)), Repository.class);
    }

    /**
     * Fork a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param option
     *            CreateForkOption
     * @return Repository
     */
    public Repository forks(String owner, String repo, CreateForkOption option) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/forks", owner, repo), option), Repository.class);
    }

    /**
     * Gets the blob of a repository.
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            sha of the commit
     * @return GitBlobResponse
     */
    public GitBlobResponse blob(String owner, String repo, String sha) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/git/blobs/%s", owner, repo, sha)), GitBlobResponse.class);
    }

    /**
     * Get a single commit from a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            the commit hash
     * @return Commit
     */
    public Commit commit(String owner, String repo, String sha) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/git/commits/%s", owner, repo, sha)), Commit.class);
    }

    /**
     * Get specified ref or filtered repository's refs
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return ReferenceList
     */
    public List<Reference> references(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/git/refs", owner, repo)), Reference.class);
    }

    /**
     * Get specified ref or filtered repository's refs
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param ref
     *            part or full name of the ref
     * @return ReferenceList
     */
    public List<Reference> references(String owner, String repo, String ref) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/git/refs/%s", owner, repo, ref)), Reference.class);
    }

    /**
     * Gets the tag object of an annotated tag (not lightweight tags)
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            sha of the tag. The Git tags API only supports annotated tag
     *            objects, not lightweight tags.
     * @return AnnotatedTag
     */
    public AnnotatedTag tag(String owner, String repo, String sha) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/git/tags/%s", owner, repo, sha)), AnnotatedTag.class);
    }

    /**
     * Gets the tree of a repository.
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            sha of the commit
     * @param recursive
     *            show all directories and files
     * @param page
     *            page number; the 'truncated' field in the response will be
     *            true if there are still more items after this page, false if
     *            the last page
     * @param perPage
     *            number of items per page; default is 1000 or what is set in
     *            app.ini as DEFAULT_GIT_TREES_PER_PAGE
     * @return GitTreeResponse
     */
    public GitTreeResponse tree(String owner, String repo, String sha, boolean recursive, long page, long perPage) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/git/trees/%s", owner, repo, sha),
                                                   Maps.NEW("recursive", recursive)
                                                       .add("page", page)
                                                       .add("per_page", perPage),
                                                   null),
                                     GitTreeResponse.class);
    }

    /**
     * List the hooks in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return HookList
     */
    public List<Hook> hooks(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/hooks", owner, repo)), Hook.class);
    }

    /**
     * Create a hook
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param option
     *            CreateHookOption
     * @return Hook
     */
    public Hook hooks(String owner, String repo, CreateHookOption option) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/hooks", owner, repo), option), Hook.class);
    }

    /**
     * List the Git hooks in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return GitHookList
     */
    public List<GitHook> gitHooks(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/hooks/git", owner, repo)), GitHook.class);
    }

    /**
     * Get a Git hook
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to get
     * @return GitHook
     */
    public GitHook gitHook(String owner, String repo, String id) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/hooks/git/%s", owner, repo, id)), GitHook.class);
    }

    /**
     * Delete a Git hook in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to get
     * @return success true else false
     */
    public boolean deleteGitHook(String owner, String repo, String id) {
        return apiClient.delete(String.format("/repos/%s/%s/hooks/git/%s", owner, repo, id)).isOk();
    }

    /**
     * Edit a Git hook in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to edit
     * @param option
     *            EditGitHookOption
     * @return GitHook
     */
    public GitHook gitHook(String owner, String repo, String id, EditGitHookOption option) {
        return apiClient.deserialize(apiClient.patch(String.format("/repos/%s/%s/hooks/git/%s", owner, repo, id), option),
                                     GitHook.class);
    }

    /**
     * Get a hook
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to get
     * @return Hook
     */
    public Hook hook(String owner, String repo, String id) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/hooks/%s", owner, repo, id)), Hook.class);
    }

    /**
     * Delete a hook in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to get
     * @return success true else false
     */
    public boolean deleteHook(String owner, String repo, String id) {
        return apiClient.delete(String.format("/repos/%s/%s/hooks/%s", owner, repo, id)).isOk();
    }

    /**
     * Edit a hook in a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to edit
     * @param option
     *            EditHookOption
     * @return Hook
     */
    public Hook hook(String owner, String repo, String id, EditHookOption option) {
        return apiClient.deserialize(apiClient.patch(String.format("/repos/%s/%s/hooks/%s", owner, repo, id), option),
                                     Hook.class);
    }

    /**
     * Test a push webhook
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the hook to test
     * @return success true else false
     */
    public boolean testHook(String owner, String repo, String id) {
        return apiClient.get(String.format("/repos/%s/%s/hooks/%s/tests", owner, repo, id)).isOk();
    }

    /**
     * List a repository's keys
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param keyId
     *            the key_id to search for
     * @param fingerprint
     *            fingerprint of the key
     * @return DeployKeyList
     */
    public List<DeployKey> deployKeys(String owner, String repo, long keyId, String fingerprint) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/keys", owner, repo),
                                                         Maps.NEW("key_id", keyId)
                                                             .add("fingerprint", fingerprint),
                                                         null),
                                           DeployKey.class);
    }

    /**
     * Add a key to a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param option
     *            CreateKeyOption
     * @return DeployKey
     */
    public DeployKey deployKey(String owner, String repo, CreateKeyOption option) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/keys", owner, repo), option), DeployKey.class);
    }

    /**
     * Get a repository's key by id
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the key to get
     * @return DeployKey
     */
    public DeployKey deployKey(String owner, String repo, long id) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/keys/%d", owner, repo, id)), DeployKey.class);

    }

    /**
     * Delete a key from a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the key to delete
     * @return success true else false
     */
    public boolean deleteDeployKey(String owner, String repo, long id) {
        return apiClient.delete(String.format("/repos/%s/%s/keys/%d", owner, repo, id)).isOk();
    }

    /**
     * Sync a mirrored repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return success true else false
     */
    public boolean sync(String owner, String repo) {
        return apiClient.post(String.format("/repos/%s/%s/mirror-sync", owner, repo), null).isOk();
    }

    /**
     * List a repo's pull requests
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param page
     *            Page number
     * @param state
     *            State of pull request: open or closed (optional)
     * 
     *            Available values : closed, open, all
     * @param sort
     *            Type of sort
     * 
     *            Available values : oldest, recentupdate, leastupdate,
     *            mostcomment, leastcomment, priority
     * @param milestone
     *            ID of the milestone
     * @param labels
     *            Label IDs
     * @return PullRequestList
     */
    public List<PullRequest> pullRequests(String owner, String repo, long page, String state, String sort, long milestone, long[] labels) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/pulls", owner, repo),
                                                         Maps.NEW("page", page)
                                                             .add("state", state)
                                                             .add("sort", sort)
                                                             .add("milestone", milestone)
                                                             .add("labels", labels),
                                                         null),
                                           PullRequest.class);
    }

    /**
     * Create a pull request
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param option
     *            CreatePullRequestOption
     * @return PullRequest
     */
    public PullRequest pullRequest(String owner, String repo, CreatePullRequestOption option) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/pulls", owner, repo), option), PullRequest.class);
    }

    /**
     * Get a pull request
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param index
     *            index of the pull request to get
     * @return PullRequest
     */
    public PullRequest pullRequest(String owner, String repo, long index) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/pulls/%d", owner, repo, index)), PullRequest.class);
    }

    /**
     * Update a pull request. If using deadline only the date will be taken into
     * account, and time of day ignored.
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param index
     *            index of the pull request to edit
     * @param option
     *            EditPullRequestOption
     * @return PullRequest
     */
    public PullRequest pullRequest(String owner, String repo, long index, EditPullRequestOption option) {
        return apiClient.deserialize(apiClient.patch(String.format("/repos/%s/%s/pulls/%d", owner, repo, index), option),
                                     PullRequest.class);
    }

    /**
     * Check if a pull request has been merged
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param index
     *            index of the pull request
     * @return pull request has been merged true
     */
    public boolean merged(String owner, String repo, long index) {
        return apiClient.get(String.format("/repos/%s/%s/pulls/%d/merge", owner, repo, index)).isOk();
    }

    /**
     * Merge a pull request
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param index
     *            index of the pull request
     * @param option
     *            MergePullRequestOption
     * @return success true else false
     */
    public boolean merge(String owner, String repo, long index, MergePullRequestOption option) {
        return apiClient.postBody(String.format("/repos/%s/%s/pulls/%d/merge", owner, repo, index), option).isOk();
    }

    /**
     * Get a file from a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param filepath
     *            filepath of the file to get
     * @return success
     */
    public boolean raw(String owner, String repo, String filepath) {
        return apiClient.get(String.format("/repos/%s/%s/raw/%s", owner, repo, filepath)).isOk();
    }

    /**
     * List a repo's releases
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param page
     *            page wants to load
     * @param perPage
     *            items count every page wants to load
     * @return ReleaseList
     */
    public List<Release> releases(String owner, String repo, long page, long perPage) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/releases", owner, repo),
                                                         Maps.NEW("page", page)
                                                             .add("per_page", perPage),
                                                         null),
                                           Release.class);
    }

    /**
     * Create a release
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param option
     *            CreateReleaseOption
     * @return Release
     */
    public Release release(String owner, String repo, CreateReleaseOption option) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/releases", owner, repo), option), Release.class);
    }

    /**
     * Get a release
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release to get
     * @return Release
     */
    public Release release(String owner, String repo, long id) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/releases/%d", owner, repo, id)), Release.class);
    }

    /**
     * Delete a release
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release to delete
     * @return success true else false
     */
    public boolean releases(String owner, String repo, long id) {
        return apiClient.delete(String.format("/repos/%s/%s/releases/%d", owner, repo, id)).isOk();
    }

    /**
     * Update a release
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release to edit
     * @param option
     *            EditReleaseOption
     * @return Release
     */
    public Release release(String owner, String repo, long id, EditReleaseOption option) {
        return apiClient.deserialize(apiClient.patch(String.format("/repos/%s/%s/releases/%d", owner, repo, id), option), Release.class);
    }

    /**
     * List release's attachments
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release
     * @return AttachmentList
     */
    public List<Attachment> attachments(String owner, String repo, long id) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/releases/%d/assets", owner, repo, id)),
                                           Attachment.class);
    }

    /**
     * Create a release attachment
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release
     * @param name
     *            name of the attachment
     * @param file
     *            attachment to upload
     * @return Attachment
     */
    public Attachment attachment(String owner, String repo, long id, String name, File file) {
        return apiClient.deserialize(apiClient.post(String.format("/repos/%s/%s/releases/%d/assets", owner, repo, id),
                                                    Maps.NEW("name", name)
                                                        .add("attachment", file)),
                                     Attachment.class);
    }

    /**
     * Get a release attachment
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release
     * @param attachmentId
     *            id of the attachment to get
     * @return Attachment
     */
    public Attachment attachment(String owner, String repo, long id, long attachmentId) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/releases/%d/assets/%d", owner, repo, id, attachmentId)),
                                     Attachment.class);
    }

    /**
     * Delete a release attachment
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release
     * @param attachmentId
     *            id of the attachment to delete
     * @return success true else false
     */
    public boolean attachments(String owner, String repo, long id, long attachmentId) {
        return apiClient.delete(String.format("/repos/%s/%s/releases/%d/assets/%d", owner, repo, id, attachmentId)).isOk();
    }

    /**
     * Edit a release attachment
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param id
     *            id of the release
     * @param attachmentId
     *            id of the attachment to edit
     * @param options
     *            EditAttachmentOptions
     * @return Attachment
     */
    public Attachment attachment(String owner, String repo, long id, long attachmentId, EditAttachmentOptions options) {
        return apiClient.deserialize(apiClient.patch(String.format("/repos/%s/%s/releases/%d/assets/%d", owner, repo, id, attachmentId),
                                                     options),
                                     Attachment.class);
    }

    /**
     * Get signing-key.gpg for given repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return GPG armored public //TODO key maybe a file
     */
    public boolean signingGpgKey(String owner, String repo) {
        return apiClient.get(String.format("/repos/%s/%s/signing-key.gpg", owner, repo)).isOk();
    }

    /**
     * List a repo's stargazers
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return UserList
     */
    public List<User> stargazers(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/stargazers", owner, repo)), User.class);
    }

    /**
     * Get a commit's statuses
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            sha of the commit
     * @param page
     *            page number of results
     * @param sort
     *            type of sort
     * 
     *            Available values : oldest, recentupdate,
     *            leastupdate,leastindex, highestindex
     * @param state
     *            type of state
     * 
     *            Available values : pending, success, error, failure, warning
     * @return StatusList
     */
    public List<Status> statuses(String owner, String repo, String sha, long page, String sort, String state) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/statuses/sha", owner, repo),
                                                         Maps.NEW("page", page)
                                                             .add("sort", sort)
                                                             .add("state", state),
                                                         null),
                                           Status.class);

    }

    /**
     * Create a commit status
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param sha
     *            sha of the commit
     * @param option
     *            CreateStatusOption
     * @return Status
     */
    public Status status(String owner, String repo, String sha, CreateStatusOption option) {
        return apiClient.deserialize(apiClient.postBody(String.format("/repos/%s/%s/statuses/sha", owner, repo), option), Status.class);
    }

    /**
     * List a repo's watchers
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return UserList
     */
    public List<User> watchers(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/subscribers", owner, repo)), User.class);
    }

    /**
     * Check if the current user is watching a repo
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return WatchInfo
     */
    public WatchInfo watching(String owner, String repo) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/subscription", owner, repo)), WatchInfo.class);
    }

    /**
     * Watch a repo
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return WatchInfo
     */
    public WatchInfo watch(String owner, String repo) {
        return apiClient.deserialize(apiClient.put(String.format("/repos/%s/%s/subscription", owner, repo)), WatchInfo.class);
    }

    /**
     * Unwatch a repo
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return success true else false
     */
    public boolean unwatch(String owner, String repo) {
        return apiClient.delete(String.format("/repos/%s/%s/subscription", owner, repo)).isOk();
    }

    /**
     * List a repository's tags
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return TagList
     */
    public List<Tag> tags(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/tags", owner, repo)), Tag.class);
    }

    /**
     * List a repo's tracked times
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return TrackedTimeList
     */
    public List<TrackedTime> trackedTimes(String owner, String repo) {
        return apiClient.deserializeAsList(apiClient.get(String.format("/repos/%s/%s/times", owner, repo)), TrackedTime.class);
    }

    /**
     * Get list of topics that a repository has
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @return TopicNames
     */
    public TopicName topics(String owner, String repo) {
        return apiClient.deserialize(apiClient.get(String.format("/repos/%s/%s/topics", owner, repo)), TopicName.class);
    }

    /**
     * Replace list of topics for a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param options
     *            RepoTopicOptions
     * @return success true else false
     */
    public boolean topics(String owner, String repo, RepoTopicOptions options) {
        return apiClient.put(String.format("/repos/%s/%s/topics", owner, repo), options).isOk();
    }

    /**
     * Add a topic to a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param topic
     *            name of the topic to add
     * @return success true else false
     */
    public boolean topic(String owner, String repo, String topic) {
        return apiClient.put(String.format("/repos/%s/%s/topics/%s", owner, repo, topic)).isOk();
    }

    /**
     * Delete a topic from a repository
     * 
     * @param owner
     *            owner of the repo
     * @param repo
     *            name of the repo
     * @param topic
     *            name of the topic to delete
     * @return success true else false
     */
    public boolean topics(String owner, String repo, String topic) {
        return apiClient.delete(String.format("/repos/%s/%s/topics/%s", owner, repo, topic)).isOk();
    }

    /**
     * Get a repository by id
     * 
     * @param id
     *            id of the repo to get
     * @return Repository
     */
    public Repository repository(long id) {
        return apiClient.deserialize(apiClient.get(String.format("/repositories/%d", id)), Repository.class);
    }

    /**
     * search topics via keyword
     * 
     * @param key
     *            keywords to search
     * @return TopicListResponse
     */
    public List<TopicResponse> search(String key) {
        return apiClient.deserializeAsList(apiClient.get("/topics/search", Maps.NEW("q", key), null), TopicResponse.class);
    }

    /**
     * Create a repository
     * 
     * @param repository
     *            CreateRepoOption
     * @return Repository
     */
    public Repository repository(CreateRepoOption repository) {
        return apiClient.deserialize(apiClient.postBody("/user/repos", repository), Repository.class);
    }

}
